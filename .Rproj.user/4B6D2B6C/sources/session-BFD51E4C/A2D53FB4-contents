# Load the package
library(jpeg)
url <- "https://t3.ftcdn.net/jpg/06/10/68/10/360_F_610681075_9NnfeAB9rIjAccA11S0lmIbEfdt1RMEM.jpg"
url <- "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgubnFMq4Ex3R0Csr6YexaRJ5NYpgXp94xHo58rlluSPwCTaaBZ_t1J8XUXKjUcF1TAuQ7MxoU5iXRhojop0NPLTjm1_NsaqTWzxT4GawvVRbfvWakepNpqqZohCWrrzIzXMoimpsOMECZa/s1600/ColorfulBird.jpg" 
# Download the file and save it as "Image.jpg" in the directory
dFile <- download.file(url, "Image.jpg")
img <- readJPEG("Image.jpg") # Read the image


# Obtain the dimension
imgDm <- dim(img)

# Assign RGB channels to data frame
imgRGB <- data.frame(
  x = rep(1:imgDm[2], each = imgDm[1]),
  y = rep(imgDm[1]:1, imgDm[2]),
  R = as.vector(img[,,1]),
  G = as.vector(img[,,2]),
  B = as.vector(img[,,3])
)



library(ggplot2)

# ggplot theme to be used
plotTheme <- function() {
  theme(
    panel.background = element_rect(
      linewidth = 3,
      colour = "black",
      fill = "white"),
    axis.ticks = element_line(
      size = 2),
    panel.grid.major = element_line(
      colour = "gray80",
      linetype = "dotted"),
    panel.grid.minor = element_line(
      colour = "gray90",
      linetype = "dashed"),
    axis.title.x = element_text(
      size = rel(1.2),
      face = "bold"),
    axis.title.y = element_text(
      size = rel(1.2),
      face = "bold"),
    plot.title = element_text(
      size = 20,
      face = "bold",
      vjust = 1.5)
  )
}

# Plot the image
ggplot(data = imgRGB, aes(x = x, y = y)) + 
  geom_raster(fill = rgb(imgRGB[c("R", "G", "B")])) +
  labs(title = "Original Image: Colorful Bird") +
  xlab("x") +
  ylab("y") +
  theme_bw()
  #plotTheme()



# applying clustering only to the colors RGB, not the x, y positions
kClusters <- 8
kMeans <- kmeans(imgRGB[, c("R", "G", "B")], centers = kClusters)
kColours <- rgb(kMeans$centers[kMeans$cluster,])

ggplot(data = imgRGB, aes(x = x, y = y)) + 
  # geom_point(colour = kColours) + # too slow!!!
  geom_raster(fill = kColours) +
  labs(title = paste("k-Means Clustering of", kClusters, "Colours")) +
  xlab("x") +
  ylab("y") +
  theme_bw()
# plotTheme()




##### modified to use pixel location and color
feat <- imgRGB[, c("x","y","R","G","B")]
feat_scaled <- scale(feat)         # standardize all 5 features

set.seed(1)
kClusters <- 10
km5 <- kmeans(feat_scaled, centers = kClusters, nstart = 5)

# 2) Classe de cada pixel
imgRGB$cluster <- km5$cluster

# 3) Paleta: média do RGB original por cluster (0-1)
palette <- imgRGB %>%
  group_by(cluster) %>%
  summarize(
    R = mean(R),
    G = mean(G),
    B = mean(B),
    .groups = "drop"
  ) %>%
  mutate(hex = rgb(R, G, B))

# 4) Anexa a cor de cada cluster a cada pixel
imgRGB_plot <- imgRGB %>%
  left_join(palette, by = "cluster")

# 5) Plot (raster é mais rápido que point por pixel)
ggplot(imgRGB_plot, aes(x = x, y = y, fill = hex)) +
  geom_raster() +
  scale_fill_identity() +
  coord_equal() +
  labs(title = paste("k-means in 5D (x,y,RGB) with", kClusters, "colors")) +
  theme_void()


# ----------------------
# PARTE 2:

library(dplyr)
library(ggplot2)
library(cluster)       # silhouette
library(raster); library(sp); library(RColorBrewer)

data.loc <- "https://raw.githubusercontent.com/allanvc/data_FGV/master/image_naivebayes/"
satellite_data <- read.csv(paste0(data.loc, "satellite_data.csv"))

# Seleciona apenas as bandas
bands <- c("B2","B3","B4","B6","B7","B8","B8A","B11","B12")
X <- satellite_data[, bands]

# Padronizar (muito importante p/ k-means)
Xs <- scale(X)


set.seed(1984)
id_sub <- sample(seq_len(nrow(Xs)), min(5000, nrow(Xs)))
Xs_sub <- Xs[id_sub, ]

# 1) Cotovelo: soma dos quadrados intra (WSS)
wss <- sapply(2:10, function(k) kmeans(Xs_sub, centers=k, nstart=10)$tot.withinss)

# 2) Silhueta média (maior é melhor)
sil <- sapply(2:10, function(k) {
  km <- kmeans(Xs_sub, centers=k, nstart=10)
  ss <- silhouette(km$cluster, dist(Xs_sub))
  mean(ss[, 3])
})

data.frame(k=2:10, wss=wss, silhouette=sil)

k <- 3  # ajuste conforme seus gráficos/intuíção
set.seed(1984)
km <- kmeans(Xs, centers = k, nstart = 20, iter.max = 100)

# Guardar centros e parâmetros da escala p/ predição no grid
centers <- km$centers
sc_mu <- attr(Xs, "scaled:center")
sc_sd <- attr(Xs, "scaled:scale")


grid.df <- read.csv(paste0(data.loc, "prediction_grid_data.csv"))

# Padroniza com os mesmos parâmetros
grid_mat <- as.matrix(grid.df[, bands])
grid_scaled <- sweep(grid_mat, 2, sc_mu, FUN = "-")
grid_scaled <- sweep(grid_scaled, 2, sc_sd, FUN = "/")

# Função para achar centro mais próximo
nearest_center <- function(M, centers) {
  # retorna índice do cluster mais próximo para cada linha de M
  # (distância euclidiana)
  idx <- apply(M, 1, function(v) {
    d <- colSums((t(centers) - v)^2)
    which.min(d)
  })
  as.integer(idx)
}

grid.df$cluster <- nearest_center(grid_scaled, centers)

# Converte para raster (clusters 1..k)
spdf <- sp::SpatialPointsDataFrame(grid.df[, c("x","y")], data = grid.df,
                                   proj4string = sp::CRS("+proj=longlat +datum=WGS84"))
r <- raster::rasterFromXYZ(as.data.frame(spdf)[, c("x","y","cluster")])
# writeRaster(r, "KM_Clusters.tif", "GTiff", overwrite=TRUE)


# Cores distintas para k classes
# garanta um nome coerente
names(r) <- "cluster"

# paleta com k cores
myCols <- colorRampPalette(RColorBrewer::brewer.pal(max(3, min(8, k)), "Set2"))(k)
labs_k <- paste("Cluster", 1:k)

img <- sp::spplot(
  r,
  main = sprintf("Clustering espectral (k-means, k=%d)", k),
  col.regions = myCols,
  at = seq(0.5, k + 0.5, by = 1),
  colorkey = list(
    space = "right",
    labels = list(at = 1:k, labels = labs_k, cex = 0.9)
  ),
  par.settings = list(axis.line = list(col = "transparent")) # opcional
)
print(img)



# plot nas cores:
library(dplyr)
library(raster)
library(sp)
#library(RStoolbox)  # ggRGB opcional

# 1) Constrói um RasterBrick com as bandas "true color"
#    (ajuste os nomes se necessário)
rR <- rasterFromXYZ(grid.df[, c("x","y","B4")])  # Red
rG <- rasterFromXYZ(grid.df[, c("x","y","B3")])  # Green
rB <- rasterFromXYZ(grid.df[, c("x","y","B2")])  # Blue
rb <- brick(rR, rG, rB)
names(rb) <- c("R","G","B")

# 2) Stretch de contraste (evitar imagem lavada)
#    use "hist" ou "lin" conforme preferir
plotRGB(rb, r=1, g=2, b=3, stretch="lin")   # ou stretch="hist"

# 3) Converte clusters em raster e extrai contornos
rc <- rasterFromXYZ(grid.df[, c("x","y","cluster")])
pol <- rasterToPolygons(rc, dissolve = TRUE)

# 4) Plota contornos por cima (transparente, só bordas)
plot(pol, add = TRUE, border = "yellow", lwd = 1.2)   # escolha a cor das linhas




# ---------------

library(dplyr)
library(sp)
library(raster)
library(RColorBrewer)

# --- Função de stretch por percentis (2–98%), devolve em [0,1]
stretch01 <- function(v, p = c(0.02, 0.98)) {
  qs <- quantile(v, p, na.rm = TRUE)
  out <- (pmin(pmax(v, qs[1]), qs[2]) - qs[1]) / (qs[2] - qs[1])
  as.numeric(out)
}

# 1) Calcula stretch global das bandas (pra cores ficarem proporcionais)
R01 <- stretch01(grid.df$B4)
G01 <- stretch01(grid.df$B3)
B01 <- stretch01(grid.df$B2)

tmp <- grid.df %>%
  mutate(R01 = R01, G01 = G01, B01 = B01)

# 2) Cor “true color” representativa de cada cluster (mediana após stretch)
pal_tbl <- tmp %>%
  group_by(cluster) %>%
  summarise(R = median(R01, na.rm=TRUE),
            G = median(G01, na.rm=TRUE),
            B = median(B01, na.rm=TRUE),
            .groups = "drop") %>%
  mutate(hex = rgb(R, G, B))

# 3) Mapa categórico: cada célula recebe a cor do seu cluster
cols <- pal_tbl$hex[match(tmp$cluster, pal_tbl$cluster)]   # vetor hex por célula

# 4) Constrói raster de clusters e plota com as cores “naturais”
rc <- rasterFromXYZ(tmp[, c("x","y","cluster")])
names(rc) <- "cluster"

# spplot com paleta baseada nas cores "true color" dos clusters
labs_k <- paste("Cluster", sort(unique(tmp$cluster)))
myCols <- pal_tbl$hex[order(pal_tbl$cluster)]

img <- sp::spplot(
  rc, "cluster",
  main = sprintf("k-means (k=%d) — cores médias 'true color' por cluster", length(unique(tmp$cluster))),
  col.regions = myCols,
  at = seq(0.5, max(tmp$cluster)+0.5, by=1),
  colorkey = list(space="right",
                  labels = list(at = sort(unique(tmp$cluster)), labels = labs_k))
)
print(img)
